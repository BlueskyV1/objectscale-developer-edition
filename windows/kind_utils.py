import os
from os import path
import subprocess
import zipfile
import sys
import urllib.request

class kind_utility:
    kind_url = 'https://storage.googleapis.com/kubernetes-release/release/v1.19.0/bin/windows/amd64/kubectl.exe'
    kind_install_path = 'C:\\Windows'
    kind_config_path = 'C:\\Windows\\Kind_configuration.yaml'
    is_valid_install = False
    kind_path = ''

    def __init__(self):
        self.is_valid_install = False


    def install_kind(self):
        # Change to user downloads folder
        current_path = os.getcwd()
        os.chdir(os.getenv('HOMEPATH') + '\\Downloads')
        if not path.exists(os.getenv('HOMEPATH') + '\\Downloads\\kind.exe'):
            print('Starting Download of Helm.')
            local_filename, headers = urllib.request.urlretrieve(self.kind_url, os.getenv('HOMEPATH') + '\\Downloads\\kind.exe')

        install_path_exists = path.exists(self.kind_install_path)
        if not install_path_exists:
            os.mkdir(self.kind_install_path)

        os.system('ROBOCOPY \"' + os.getenv('HOMEPATH') + '\\Downloads\\kind.exe\" ' + self.kind_install_path + ' /NDL /NFL')


    def check_kind_installation(self, PATH=os.getenv('PATH')):
        print('Verifying kind Installation.')

        self.is_valid_install = self.find_kind_in_PATH(PATH=PATH)

        return self.is_valid_install, self.kind_path


    def find_kind_in_PATH(self, PATH=os.getenv('PATH')) -> bool:

        # Split into paths to search for helm
        paths = PATH.split(';')
        for filePath in paths:
            if not os.path.isdir(filePath):
                paths.remove(filePath)

        # Accumulate list of files until helm.exe is found.
        files = []
        for filePath in paths:
            files.extend([f for f in os.listdir(filePath) if os.path.isfile(os.path.join(filePath, f))])
            if 'kind.exe' in files:
                self.is_valid_install = True
                self.kind_path = filePath
                break

        return self.is_valid_install

    def clean_kind(self, node_count = 2):
        print('Cleaning kind.')
        self.delete_config()
        current_config = self.generate_config(node_count=node_count)
        config_file = open(self.kind_config_path, 'w+b')
        config_file.write(current_config)
        print('Config file refreshed.')
        print('Kind cleaned.')

    def delete_config(self):
        print('Deleting old Kind config')

        if not path.exists(self.kind_config_path):
            print('No configuration to delete.')
        else:
            os.remove(self.kind_config_path)


    def generate_config(self, node_count = 2) -> str:
        print('Generating configuration for '+str(node_count)+' nodes.')

        if node_count == 1:
            print('Error: cannot generate configuration for one node, use Minikube instead.')
            return '    ' #returning a tab will cause an invalid YAML error

        config = ''
        config += 'kind: Cluster\r\n'
        config += 'apiVersion: kind.x-k8s.io/v1alpha4 \r\n'
        config += '# Configuration automatically generated by Objectscale Developer Edition.\r\n'
        config += '# To get the default configuration visit https://kind.sigs.k8s.io/docs/user/configuration/\r\n'
        config += '# Configuration generated for '+str(node_count)+' nodes.\r\n'
        config += '\r\n'
        config += 'nodes:\r\n'
        config += '- role: control-plane\r\n'
        nodes_added = 1
        while nodes_added < node_count:
            config += '- role: worker\r\n'

        return config
